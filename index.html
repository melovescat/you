<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bias‑Filtered Face Viewer</title>
  <!--
    This single HTML document includes all CSS and JavaScript inline so it can
    be served without any external dependencies. It implements a client‑side
    demonstration of skin tone normalisation. When a user uploads a photo,
    their image is displayed alongside a processed version in which detected
    skin regions are shifted towards a uniform dark brown tone (hex #4f2421)
    while facial features and shading are preserved. The layout is responsive
    and mobile‑friendly.
  -->
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.5;
      background-color: #f9fafb;
      color: #333;
    }

    header {
      background-color: #2d2d2d;
      color: #ffffff;
      padding: 2rem 1rem;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
    }

    header p {
      margin-top: 0.5rem;
      font-size: 1rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    main {
      max-width: 960px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .upload {
      text-align: center;
      margin-bottom: 2rem;
    }

    .upload input[type="file"] {
      padding: 0.5rem;
      font-size: 1rem;
    }

    .results {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      margin-bottom: 2rem;
    }

    .hidden {
      display: none;
    }

    .image-container {
      text-align: center;
      flex: 1 1 45%;
      margin: 1rem;
    }

    .image-container h2 {
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
    }

    .image-container img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .info {
      background-color: #ffffff;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .info h3 {
      margin-top: 0;
      font-size: 1.3rem;
    }

    .info ul {
      list-style: disc inside;
      padding-left: 0;
    }

    .info li {
      margin-bottom: 0.5rem;
    }

    footer {
      background-color: #2d2d2d;
      color: #ffffff;
      text-align: center;
      padding: 1rem;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <header>
    <h1>See the bias‑filtered version of your face</h1>
    <p>Upload a photo to explore how much of beauty perception is tied to skin tone.</p>
  </header>
  <main>
    <section class="upload">
      <input type="file" id="fileInput" accept="image/*">
    </section>
    <section id="results" class="results hidden">
      <div class="image-container">
        <h2>Original</h2>
        <img id="originalImage" alt="Original image">
      </div>
      <div class="image-container">
        <h2>Bias‑Filtered</h2>
        <img id="processedImage" alt="Bias filtered image">
      </div>
    </section>
    <section class="info">
      <h3>What we change and what we keep</h3>
      <ul>
        <li>We keep your facial features: bone structure, nose, lips, eyes, jawline and expression.</li>
        <li>We adjust skin tone towards a dark brown reference tone (approximate hex #4f2421) while preserving each pixel’s lightness and shading.</li>
        <li>This is an educational tool to help you understand bias, not a beauty filter.</li>
      </ul>
    </section>
  </main>
  <footer>
    <p>&copy; 2025 Unbiased Beauty. All rights reserved.</p>
  </footer>
  <script>
    /*
     * Client‑side image processing for the bias‑filtered face viewer. When the user
     * uploads an image, it displays both the original and a processed version in which
     * detected skin regions are shifted towards a dark brown tone while preserving
     * shading differences. The script uses a simple YCbCr threshold to detect skin
     * pixels and adjusts their lightness and chroma in the CIELAB space so that the
     * average skin tone matches the target colour. Non‑skin pixels remain unchanged.
     */
    document.addEventListener('DOMContentLoaded', () => {
      const fileInput = document.getElementById('fileInput');
      const originalImage = document.getElementById('originalImage');
      const processedImage = document.getElementById('processedImage');
      const resultsSection = document.getElementById('results');

      fileInput.addEventListener('change', event => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
          const dataURL = e.target.result;
          originalImage.src = dataURL;
          processImage(dataURL).then(processedURL => {
            processedImage.src = processedURL;
            resultsSection.classList.remove('hidden');
          }).catch(err => {
            console.error('Error processing image:', err);
          });
        };
        reader.readAsDataURL(file);
      });

      async function processImage(dataURL) {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Colour space helpers
            function pivotRGBToLinear(v) {
              return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
            }
            function linearToSRGB(v) {
              return v <= 0.0031308 ? 12.92 * v : 1.055 * Math.pow(v, 1 / 2.4) - 0.055;
            }
            function xyzToLab(x, y, z) {
              x /= 0.95047;
              y /= 1.0;
              z /= 1.08883;
              const epsilon = 0.008856;
              const kappa = 903.3;
              function f(t) {
                return t > epsilon ? Math.cbrt(t) : (kappa * t + 16) / 116;
              }
              const fx = f(x), fy = f(y), fz = f(z);
              const L = 116 * fy - 16;
              const a = 500 * (fx - fy);
              const b = 200 * (fy - fz);
              return { L, a, b };
            }
            function labToXyz(L, a, b) {
              const fy = (L + 16) / 116;
              const fx = fy + a / 500;
              const fz = fy - b / 200;
              const epsilon = 0.008856;
              const kappa = 903.3;
              function fInv(t) {
                return t ** 3 > epsilon ? t ** 3 : (116 * t - 16) / kappa;
              }
              let xr = fInv(fx);
              let yr = fInv(fy);
              let zr = fInv(fz);
              xr *= 0.95047;
              yr *= 1.0;
              zr *= 1.08883;
              return { x: xr, y: yr, z: zr };
            }

            // Simple skin detector using YCbCr thresholds
            function isSkinPixel(r, g, b) {
              const Y = 0.299 * r + 0.587 * g + 0.114 * b;
              const Cb = 128 - 0.168736 * r - 0.331264 * g + 0.5 * b;
              const Cr = 128 + 0.5 * r - 0.418688 * g - 0.081312 * b;
              return (Cr >= 133 && Cr <= 173) && (Cb >= 77 && Cb <= 127);
            }

            // Compute average L,a,b over skin pixels
            let sumL = 0, sumA = 0, sumB = 0, skinCount = 0;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i], g = data[i + 1], b = data[i + 2];
              if (isSkinPixel(r, g, b)) {
                const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                const R = pivotRGBToLinear(rNorm);
                const G = pivotRGBToLinear(gNorm);
                const B = pivotRGBToLinear(bNorm);
                const X = R * 0.4124 + G * 0.3576 + B * 0.1805;
                const Yc = R * 0.2126 + G * 0.7152 + B * 0.0722;
                const Z = R * 0.0193 + G * 0.1192 + B * 0.9505;
                const lab = xyzToLab(X, Yc, Z);
                sumL += lab.L;
                sumA += lab.a;
                sumB += lab.b;
                skinCount++;
              }
            }
            const avgL = skinCount ? sumL / skinCount : 0;
            const avgA = skinCount ? sumA / skinCount : 0;
            const avgB = skinCount ? sumB / skinCount : 0;

            // Target dark brown (#4f2421) in Lab space (approximate values)
            const targetL = 20.178846737231545;
            const targetA = 19.836204918739497;
            const targetB = 11.364770988442952;
            const deltaL = targetL - avgL;
            const deltaA = targetA - avgA;
            const deltaB = targetB - avgB;

            // Shift each skin pixel
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i], g = data[i + 1], b = data[i + 2];
              if (isSkinPixel(r, g, b)) {
                const rNorm = r / 255, gNorm = g / 255, bNorm = b / 255;
                const R = pivotRGBToLinear(rNorm);
                const G = pivotRGBToLinear(gNorm);
                const BVal = pivotRGBToLinear(bNorm);
                const X = R * 0.4124 + G * 0.3576 + BVal * 0.1805;
                const Yc = R * 0.2126 + G * 0.7152 + BVal * 0.0722;
                const Z = R * 0.0193 + G * 0.1192 + BVal * 0.9505;
                const { L, a, b: labB } = xyzToLab(X, Yc, Z);
                const newL = L + deltaL;
                const newA = a + deltaA;
                const newBVal = labB + deltaB;
                const { x: Xn, y: Yn, z: Zn } = labToXyz(newL, newA, newBVal);
                let Rlin = Xn * 3.2406 + Yn * -1.5372 + Zn * -0.4986;
                let Glin = Xn * -0.9689 + Yn * 1.8758 + Zn * 0.0415;
                let Blin = Xn * 0.0557 + Yn * -0.2040 + Zn * 1.0570;
                const Rout = linearToSRGB(Rlin);
                const Gout = linearToSRGB(Glin);
                const Bout = linearToSRGB(Blin);
                data[i] = Math.min(255, Math.max(0, Math.round(Rout * 255)));
                data[i + 1] = Math.min(255, Math.max(0, Math.round(Gout * 255)));
                data[i + 2] = Math.min(255, Math.max(0, Math.round(Bout * 255)));
              }
            }

            ctx.putImageData(imageData, 0, 0);
            resolve(canvas.toDataURL('image/png'));
          };
          img.src = dataURL;
        });
      }
    });
  </script>
</body>
</html>
